df_cz
# aggregate using the mode (note, we could have used 'resmapling' function too)
r_LR <- aggregate(r_HR, fact = 3, fun = getmode, na.rm = T)
# Legend is always drawn in alphabetic order
cz_lbls <- c('Af', 'Am', 'As', 'Aw', 'BSh', 'BSk', 'BWh', 'BWk', 'Cfa', 'Cfb','Cfc', 'Csa', 'Csb', 'Csc', 'Cwa','Cwb', 'Cwc', 'Dfa', 'Dfb', 'Dfc','Dfd', 'Dsa', 'Dsb', 'Dsc', 'Dsd','Dwa', 'Dwb', 'Dwc', 'Dwd', 'EF','ET', 'Ocean')
# Pack it all in legend dataframe
df_lgd <- data.frame(cz_ID = cz_IDs, cz_name = factor(cz_lbls), cz_colours = cz_cols)
# Set identifier
cz_IDs <- seq(1,32)
# Color palette for climate classification
cz_cols <- c("#960000", "#FF0000", "#FF6E6E", "#FFCCCC", "#CC8D14", "#CCAA54", "#FFCC00", "#FFFF64", "#007800", "#005000", "#003200", "#96FF00", "#00D700", "#00AA00", "#BEBE00", "#8C8C00", "#5A5A00", "#550055", "#820082", "#C800C8", "#FF6EFF", "#646464", "#8C8C8C", "#BEBEBE", "#E6E6E6", "#6E28B4", "#B464FA", "#C89BFA", "#C8C8FF", "#6496FF", "#64FFFF", "#F5FFFF")
# get the final data.frame for the climate zones
df_cz <- as.data.frame(r_LR, xy = T, long = T) %>%
rename(cz_ID = value) %>% dplyr::select(-layer) %>%
mutate(cz_major_zone = substr(cz_name, 1, 1)) %>%
left_join(df_lgd, by = "cz_ID")
# get the final data.frame for the climate zones
df_cz <- as.data.frame(r_LR, xy = T, long = T) %>%
rename(cz_ID = value) %>% dplyr::select(-layer) %>%
left_join(df_lgd, by = "cz_ID") %>%
mutate(cz_major_zone = substr(cz_name, 1, 1))
# get the final data.frame for the climate zones
df_cz <- as.data.frame(r_LR, xy = T, long = T) %>%
rename(cz_ID = value) %>% dplyr::select(-layer) %>%
left_join(df_lgd, by = "cz_ID") %>%
mutate(cz_major_zone = substr(cz_name, 1, 1)) %>%
tibble()
df_cz
dir.create(path = 'data/inter_data/ancillary_info', recursive = T, showWarnings = F)
save('df_cz', 'df_lgd', file = 'data/inter_data/ancillary_info/df_KG_climatezones.RData')
# load KG climzones (only needed for some spatial filtering)
load('data/inter_data/ancillary_info/df_KG_climatezones.RData')  # <---- df_cz
df_cz <- df_cz %>% dplyr::select(-cz_ID, -cz_colours)
df_cz
load('data/inter_data/ancillary_info/df_climspace_t2xsm.RData') # <---- df_climspace
x.bin.width <- 4
y.bin.width <- 0.04
# make bin labels
x.bin.numlbls <- seq(floor(min(df_climspace$clim.t2)),
ceiling(max(df_climspace$clim.t2)) + x.bin.width,
x.bin.width)
y.bin.numlbls <- seq(floor(min(df_climspace$clim.sm)),
ceiling((max(df_climspace$clim.sm) + y.bin.width) * 100)/100,
y.bin.width)
# make bin breaks
x.bin.breaks <- c(x.bin.numlbls - (x.bin.width/2), Inf)
y.bin.breaks <- c(y.bin.numlbls - (y.bin.width/2), Inf)
df_climspace_bin <- df_climspace %>%
mutate(t2.clim.bin = cut(clim.t2,
breaks = x.bin.breaks,
labels = x.bin.numlbls)) %>%
mutate(sm.clim.bin = cut(clim.sm,
breaks = y.bin.breaks,
labels = y.bin.numlbls))
df_climspace_bin
# Flag to remove polar areas and sea ice (useful for albedo with MODIS)
rm_polar_and_sea <- T
# should possibly be applied before/outside this script
if(rm_polar_and_sea == T){
df_comb <- df_comb %>%
right_join(y = df_cz %>% filter(cz_major_zone %in% LETTERS[1:4]),
by = c('x', 'y')) %>%
select(-cz_name, -cz_major_zone)
varname <- paste0(varname,'_cleaner')  # <-- could name it more approapriately
}
df_cz %>% filter(cz_major_zone %in% LETTERS[1:4])
varname
varname <- paste0(varname,'_cleaner')  # <-- could name it more approapriately
varname
rm_polar_and_sea <- T
# should possibly be applied before/outside this script
if(rm_polar_and_sea == T){
df_comb <- df_comb %>%
right_join(y = df_cz %>% filter(cz_major_zone %in% LETTERS[1:4]),
by = c('x', 'y')) %>%
dplyr::select(-cz_name, -cz_major_zone)
varname <- paste0(varname,'_cleaner')  # <-- could name it more approapriately
}
get.data.per.bin <- function(varname, rm_polar_and_sea = F){
load(paste0('data/inter_data/df_comb_obs_vs_sim/df_comb___', varname,'.RData'))  # <--- df_comb
# should possibly be applied before/outside this script
if(rm_polar_and_sea == T){
df_comb <- df_comb %>%
right_join(y = df_cz %>% filter(cz_major_zone %in% LETTERS[1:4]),
by = c('x', 'y')) %>%
dplyr::select(-cz_name, -cz_major_zone)
varname <- paste0(varname,'_cleaner')  # <-- could name it more approapriately
}
# filter out no data
df_comb <- df_comb %>% filter(!is.na(obs))
df_comb <- df_comb %>%
mutate(monthS = ifelse(sign(y) < 0, (month + 6) %% 12, month))  %>%
mutate(monthS = ifelse(monthS == 0, 12, monthS))  %>%
mutate(time = as.Date(x = paste(year, monthS, '15', sep = '-'))) %>%
left_join(df_climspace_bin, by = c('x', 'y'))
agr_per_clim_bin <- df_comb  %>%
group_by(t2.clim.bin, sm.clim.bin, time) %>%
summarise(N = sum(!is.na(obs)),
obs_mu = mean(obs, na.rm = T),
obs_sd = sd(obs, na.rm = T),
sim_mu = mean(sim, na.rm = T),
sim_sd = sd(sim, na.rm = T),
dif_mu = mean(sim - obs, na.rm = T),
dif_sd = sd(sim - obs, na.rm = T))
return(agr_per_clim_bin)
}
get.data.per.bin <- function(varname, rm_polar_and_sea = F){
load(paste0('data/inter_data/df_comb_obs_vs_sim/df_comb___', varname,'.RData'))  # <--- df_comb
# should possibly be applied before/outside this script
if(rm_polar_and_sea == T){
df_comb <- df_comb %>%
right_join(y = df_cz %>% filter(cz_major_zone %in% LETTERS[1:4]),
by = c('x', 'y')) %>%
dplyr::select(-cz_name, -cz_major_zone)
varname <- paste0(varname,'_cleaner')  # <-- could name it more approapriately
}
# filter out no data
df_comb <- df_comb %>% filter(!is.na(obs))
df_comb <- df_comb %>%
mutate(monthS = ifelse(sign(y) < 0, (month + 6) %% 12, month))  %>%
mutate(monthS = ifelse(monthS == 0, 12, monthS))  %>%
mutate(time = as.Date(x = paste(year, monthS, '15', sep = '-'))) %>%
left_join(df_climspace_bin, by = c('x', 'y'))
agr_per_clim_bin <- df_comb  %>%
group_by(t2.clim.bin, sm.clim.bin, time) %>%
summarise(N = sum(!is.na(obs)),
obs_mu = mean(obs, na.rm = T),
obs_sd = sd(obs, na.rm = T),
sim_mu = mean(sim, na.rm = T),
sim_sd = sd(sim, na.rm = T),
dif_mu = mean(sim - obs, na.rm = T),
dif_sd = sd(sim - obs, na.rm = T))
return(agr_per_clim_bin)
}
df_LAI_comb <- get.data.per.bin(varname = 'LAI', rm_polar_and_sea = F)
head(df_LAI_comb)
output_path <- 'data/inter_data/df_per_clim_bin'
dir.create(path = output_path, recursive = T, showWarnings = F)
source('~/work/workspace/f4p-era5-analysis/code/harvesting_data_for_final_figures/prepare_data_per_clim_bin.R')
# load/prepare dataframe with data...
load('data/inter_data/df_per_clim_bin/df_LAI_per_clim_bin.RData') # <---- df_LAI_comb
load('data/inter_data/df_per_clim_bin/df_LST_per_clim_bin.RData') # <---- df_LST_comb
by_vctr <- c("time", "t2.clim.bin", "sm.clim.bin")
df_r_all <- left_join(by = all_of(by_vctr), suffix = c("_LAI", "_LST"),
x = df_LAI_comb, y = df_LST_comb) %>%
select(by_vctr, dif_mu_LAI, dif_mu_LST, N_LAI, N_LST) %>%   #
rename(y = dif_mu_LST, x = dif_mu_LAI, ny = N_LST, nx = N_LAI) %>%
filter(!is.na(y) & !is.na(x)) %>%
filter(nx > 30 & ny > 30) %>%
filter(sm.clim.bin != 0) %>%
mutate(year = as.numeric(format(time,'%Y'))) %>%
mutate(monthS = as.numeric(format(time, '%m')))
require(tidyr)
require(dplyr)
require(tidyr)
require(sf)
head(df_LST_comb)
by_vctr <- c("time", "t2.clim.bin", "sm.clim.bin")
df_r_all <- left_join(by = all_of(by_vctr), suffix = c("_LAI", "_LST"),
x = df_LAI_comb, y = df_LST_comb) %>%
select(by_vctr, dif_mu_LAI, dif_mu_LST, N_LAI, N_LST) %>%   #
rename(y = dif_mu_LST, x = dif_mu_LAI, ny = N_LST, nx = N_LAI) %>%
filter(!is.na(y) & !is.na(x)) %>%
filter(nx > 30 & ny > 30) %>%
filter(sm.clim.bin != 0) %>%
mutate(year = as.numeric(format(time,'%Y'))) %>%
mutate(monthS = as.numeric(format(time, '%m')))
df_r_all <- left_join(by = all_of(by_vctr), suffix = c("_LAI", "_LST"),
x = df_LAI_comb, y = df_LST_comb) %>%
dplyr::select(by_vctr, dif_mu_LAI, dif_mu_LST, N_LAI, N_LST) %>%   #
rename(y = dif_mu_LST, x = dif_mu_LAI, ny = N_LST, nx = N_LAI) %>%
filter(!is.na(y) & !is.na(x)) %>%
filter(nx > 30 & ny > 30) %>%
filter(sm.clim.bin != 0) %>%
mutate(year = as.numeric(format(time,'%Y'))) %>%
mutate(monthS = as.numeric(format(time, '%m')))
df_r_all <- left_join(by = all_of(by_vctr), suffix = c("_LAI", "_LST"),
x = df_LAI_comb, y = df_LST_comb) %>%
dplyr::select(by_vctr, dif_mu_LAI, dif_mu_LST, N_LAI, N_LST) %>%   #
rename(y = dif_mu_LST, x = dif_mu_LAI, ny = N_LST, nx = N_LAI) %>%
filter(!is.na(y) & !is.na(x)) %>%
filter(nx > 30 & ny > 30) %>%
filter(sm.clim.bin != 0) %>%
mutate(year = as.numeric(format(time,'%Y'))) %>%
mutate(monthS = as.numeric(format(time, '%m')))
# define function to make plots per 2d bin
fit.hyst <- function(t2.bin.num, sm.bin.num, harmonic_n = 3){
# filter here for a section of the climspace
df <- df_r_all %>%
filter(t2.clim.bin == levels(df_r_all$t2.clim.bin)[t2.bin.num]) %>%
filter(sm.clim.bin == levels(df_r_all$sm.clim.bin)[sm.bin.num])
if(dim(df)[1] == 0){
# print('No data for this bin')
return(df_p = NULL)}
# calculate monthly averages
df_m <- df %>%
group_by(monthS) %>%
summarize(y_mu = mean(y),
x_mu = mean(x),
y_sd = sd(y),
x_sd = sd(x))
# fit the hysteresis curve decomposing x and y
# (we do it on the raw data instead of the means, but result is identical)
y <- rep(df$y, times = 3)
x <- rep(df$x, times = 3)
t <- c(df$monthS - 12, df$monthS, df$monthS + 12)
per <- 12
# simple linear fit (as general indicator... not clear if useful)
lmfit <- lm(y ~ x)
# Harmonic fit on both x and y...
if(harmonic_n == 3){   # third order harmonic fit ...
tyfit <- lm(y ~ sin(2*pi/per*t)+cos(2*pi/per*t)+sin(4*pi/per*t)+cos(4*pi/per*t)+sin(6*pi/per*t)+cos(6*pi/per*t))
txfit <- lm(x ~ sin(2*pi/per*t)+cos(2*pi/per*t)+sin(4*pi/per*t)+cos(4*pi/per*t)+sin(6*pi/per*t)+cos(6*pi/per*t))
}
if(harmonic_n == 2){   # second harmonic fit ...
tyfit <- lm(y ~ sin(2*pi/per*t)+cos(2*pi/per*t)+sin(4*pi/per*t)+cos(4*pi/per*t))
txfit <- lm(x ~ sin(2*pi/per*t)+cos(2*pi/per*t)+sin(4*pi/per*t)+cos(4*pi/per*t))
}
# # more complicated fits...
# tyfit <- lm(y ~ sin(2*pi/per*t)+cos(2*pi/per*t)+sin(4*pi/per*t)+cos(4*pi/per*t)+sin(6*pi/per*t)+cos(6*pi/per*t)+sin(8*pi/per*t)+cos(8*pi/per*t))
# txfit <- lm(x ~ sin(2*pi/per*t)+cos(2*pi/per*t)+sin(4*pi/per*t)+cos(4*pi/per*t)+sin(6*pi/per*t)+cos(6*pi/per*t)+sin(8*pi/per*t)+cos(8*pi/per*t))
# make vectors with the fitted coefficients of the harmonic fits
beta_y <- tyfit$coefficients; names(beta_y) <- paste0('b', 'y', 0:(length(tyfit$coefficients)-1))
beta_x <- txfit$coefficients; names(beta_x) <- paste0('b', 'x', 0:(length(txfit$coefficients)-1))
#assemble smoothed time series in a dedicated dataframe
df_s <- data.frame(t = seq(0.5,12.5,0.1))
df_s$y <- predict.lm(tyfit, df_s)
df_s$x <- predict.lm(txfit, df_s)
df_s$t2.clim.bin <- unique(df$t2.clim.bin)
df_s$sm.clim.bin <- unique(df$sm.clim.bin)
# make new matrix for polygon, and ensure closure
mat_coords <- matrix(data = c(df_s$x, df_s$x[1], df_s$y, df_s$y[1]),
byrow = F, ncol = 2)
# transform loop to sf object
poly_loop <- st_polygon(x = list(mat_coords), dim = 'XY')
# ensure geometry is valid (needed for abs calculation of the area)
if(st_is_valid(poly_loop) != T) poly_loop <- st_make_valid(poly_loop)
# calculate the area of each loop
loop_area <- st_area(poly_loop)
# prepare dataframe with metrics describing the curves
df_p <- data.frame(
t2.clim.bin = levels(df_r_all$t2.clim.bin)[t2.bin.num],
sm.clim.bin = levels(df_r_all$sm.clim.bin)[sm.bin.num],
xrange_s = abs(diff(range(df_s$x))),
yrange_s = abs(diff(range(df_s$y))),
x_sd_s = sd(df_s$x, na.rm = T),
y_sd_s = sd(df_s$y, na.rm = T),
areaL = loop_area,
areaE = 0.5 * sum(diff(df_s$y, lag = 2) * df_s$x[2:(length(df_s$x)-1)]),
t(beta_y), t(beta_x),
slope = lmfit$coefficients[2],
y_int = lmfit$coefficients[1],
lmRMS = sqrt(mean((lmfit$residuals)^2))
)
return(list(df_p = df_p, df_s = df_s))
}
# loop thru it all
df_p_all <- data.frame(NULL)
df_s_all <- data.frame(NULL)
for(i in 1:length(levels(df_r_all$t2.clim.bin))){
for(j in 1:length(levels(df_r_all$sm.clim.bin))){
out <- fit.hyst(i, j)
df_p_all <- bind_rows(df_p_all, out$df_p)
df_s_all <- bind_rows(df_s_all, out$df_s)
}
}
df_p_all
#### Initialization ####
require(ggplot2)
require(scales)
require(viridis)
require(tidyr)
#### Load the data ####
load('data/final_data/figures_for_paper/hysteresis_data_ready4fig.RData')   # <---- "df_r_all" "df_p_all" "df_s_all"
source('~/work/workspace/f4p-era5-analysis/code/harvesting_data_for_final_figures/prepare_hysteresis_per_bin.R')
save('df_r_all', 'df_p_all','df_s_all', file = 'data/figures_for_paper/hysteresis_data_ready4fig.RData')
require(dplyr)
require(tidyr)
require(sf)
#### Get the necessary data ####
# load/prepare dataframe with data...
load('data/inter_data/df_per_clim_bin/df_LAI_per_clim_bin.RData') # <---- df_LAI_comb
load('data/inter_data/df_per_clim_bin/df_LST_per_clim_bin.RData') # <---- df_LST_comb
#### Get the data averaged by bins ####
by_vctr <- c("time", "t2.clim.bin", "sm.clim.bin")
df_r_all <- left_join(by = all_of(by_vctr), suffix = c("_LAI", "_LST"),
x = df_LAI_comb, y = df_LST_comb) %>%
dplyr::select(by_vctr, dif_mu_LAI, dif_mu_LST, N_LAI, N_LST) %>%   #
rename(y = dif_mu_LST, x = dif_mu_LAI, ny = N_LST, nx = N_LAI) %>%
filter(!is.na(y) & !is.na(x)) %>%
filter(nx > 30 & ny > 30) %>%
filter(sm.clim.bin != 0) %>%
mutate(year = as.numeric(format(time,'%Y'))) %>%
mutate(monthS = as.numeric(format(time, '%m')))
#### Fit the hysteresis curves ####
# define function to make plots per 2d bin
fit.hyst <- function(t2.bin.num, sm.bin.num, harmonic_n = 3){
# filter here for a section of the climspace
df <- df_r_all %>%
filter(t2.clim.bin == levels(df_r_all$t2.clim.bin)[t2.bin.num]) %>%
filter(sm.clim.bin == levels(df_r_all$sm.clim.bin)[sm.bin.num])
if(dim(df)[1] == 0){
# print('No data for this bin')
return(df_p = NULL)}
# calculate monthly averages
df_m <- df %>%
group_by(monthS) %>%
summarize(y_mu = mean(y),
x_mu = mean(x),
y_sd = sd(y),
x_sd = sd(x))
# fit the hysteresis curve decomposing x and y
# (we do it on the raw data instead of the means, but result is identical)
y <- rep(df$y, times = 3)
x <- rep(df$x, times = 3)
t <- c(df$monthS - 12, df$monthS, df$monthS + 12)
per <- 12
# simple linear fit (as general indicator... not clear if useful)
lmfit <- lm(y ~ x)
# Harmonic fit on both x and y...
if(harmonic_n == 3){   # third order harmonic fit ...
tyfit <- lm(y ~ sin(2*pi/per*t)+cos(2*pi/per*t)+sin(4*pi/per*t)+cos(4*pi/per*t)+sin(6*pi/per*t)+cos(6*pi/per*t))
txfit <- lm(x ~ sin(2*pi/per*t)+cos(2*pi/per*t)+sin(4*pi/per*t)+cos(4*pi/per*t)+sin(6*pi/per*t)+cos(6*pi/per*t))
}
if(harmonic_n == 2){   # second harmonic fit ...
tyfit <- lm(y ~ sin(2*pi/per*t)+cos(2*pi/per*t)+sin(4*pi/per*t)+cos(4*pi/per*t))
txfit <- lm(x ~ sin(2*pi/per*t)+cos(2*pi/per*t)+sin(4*pi/per*t)+cos(4*pi/per*t))
}
# # more complicated fits...
# tyfit <- lm(y ~ sin(2*pi/per*t)+cos(2*pi/per*t)+sin(4*pi/per*t)+cos(4*pi/per*t)+sin(6*pi/per*t)+cos(6*pi/per*t)+sin(8*pi/per*t)+cos(8*pi/per*t))
# txfit <- lm(x ~ sin(2*pi/per*t)+cos(2*pi/per*t)+sin(4*pi/per*t)+cos(4*pi/per*t)+sin(6*pi/per*t)+cos(6*pi/per*t)+sin(8*pi/per*t)+cos(8*pi/per*t))
# make vectors with the fitted coefficients of the harmonic fits
beta_y <- tyfit$coefficients; names(beta_y) <- paste0('b', 'y', 0:(length(tyfit$coefficients)-1))
beta_x <- txfit$coefficients; names(beta_x) <- paste0('b', 'x', 0:(length(txfit$coefficients)-1))
#assemble smoothed time series in a dedicated dataframe
df_s <- data.frame(t = seq(0.5,12.5,0.1))
df_s$y <- predict.lm(tyfit, df_s)
df_s$x <- predict.lm(txfit, df_s)
df_s$t2.clim.bin <- unique(df$t2.clim.bin)
df_s$sm.clim.bin <- unique(df$sm.clim.bin)
# make new matrix for polygon, and ensure closure
mat_coords <- matrix(data = c(df_s$x, df_s$x[1], df_s$y, df_s$y[1]),
byrow = F, ncol = 2)
# transform loop to sf object
poly_loop <- st_polygon(x = list(mat_coords), dim = 'XY')
# ensure geometry is valid (needed for abs calculation of the area)
if(st_is_valid(poly_loop) != T) poly_loop <- st_make_valid(poly_loop)
# calculate the area of each loop
loop_area <- st_area(poly_loop)
# prepare dataframe with metrics describing the curves
df_p <- data.frame(
t2.clim.bin = levels(df_r_all$t2.clim.bin)[t2.bin.num],
sm.clim.bin = levels(df_r_all$sm.clim.bin)[sm.bin.num],
xrange_s = abs(diff(range(df_s$x))),
yrange_s = abs(diff(range(df_s$y))),
x_sd_s = sd(df_s$x, na.rm = T),
y_sd_s = sd(df_s$y, na.rm = T),
areaL = loop_area,
areaE = 0.5 * sum(diff(df_s$y, lag = 2) * df_s$x[2:(length(df_s$x)-1)]),
t(beta_y), t(beta_x),
slope = lmfit$coefficients[2],
y_int = lmfit$coefficients[1],
lmRMS = sqrt(mean((lmfit$residuals)^2))
)
return(list(df_p = df_p, df_s = df_s))
}
# loop thru it all
df_p_all <- data.frame(NULL)
df_s_all <- data.frame(NULL)
for(i in 1:length(levels(df_r_all$t2.clim.bin))){
for(j in 1:length(levels(df_r_all$sm.clim.bin))){
out <- fit.hyst(i, j)
df_p_all <- bind_rows(df_p_all, out$df_p)
df_s_all <- bind_rows(df_s_all, out$df_s)
}
}
##
save('df_r_all', 'df_p_all','df_s_all', file = 'data/figures_for_paper/hysteresis_data_ready4fig.RData')
save('df_r_all', 'df_p_all','df_s_all', file = 'data/final_data/figures_for_paper/hysteresis_data_ready4fig.RData')
#### Initialization ####
require(ggplot2)
require(scales)
require(viridis)
require(tidyr)
require(RColorBrewer)
require(patchwork)
#### Load the data ####
load('data/final_data/figures_for_paper/hysteresis_map_ready4fig.RData')   # <----- df_hyst_map
#### Make the plots ####
# set-up gray colours for maps
if(exists('gry_land') != T){ gry_land <- 'grey50'}
if(exists('gry_meer') != T){ gry_meer <- 'grey30'}
col_pal_BD <- c('#4B90FE', '#9BB4FA',  '#C9D2F6', '#EBECF0', '#E7DFC9', '#CEBB7B', '#AA9419' )
lgd <- theme(legend.position = 'right',
legend.key.height = unit(1.2, units = 'cm'),
panel.background = element_rect(fill = gry_land),
panel.grid = element_blank())
gds <- guides(fill = guide_colorbar(title.position = 'top', title.hjust = 0.5,
frame.colour = 'black', ticks.colour = 'black'))
lgd_map <-   theme(legend.position = 'none',
panel.background = element_rect(fill = gry_meer),
panel.grid = element_blank(),
axis.title = element_blank())
gmapBiasI <- ggplot(df_hyst_map) +
geom_tile(aes(x = x, y = y, fill = biasI)) +
scale_fill_gradientn(colours = col_pal_BD, na.value = gry_land) +
coord_cartesian(expand = F, ylim = c(-54, 86)) +
lgd_map
gcspBiasI <- ggplot(df_hyst_map) +
geom_tile(aes(x = t2.clim, y = sm.clim, fill = biasI)) +
scale_fill_gradientn('BD', colours = col_pal_BD) +
scale_x_continuous('Mean annual temperature') +
scale_y_continuous('Mean annual soil moisture') +
coord_cartesian(expand = F) +
ggtitle('Which is the dominating bias?', subtitle = '(green for LAI, red for LST)') +
lgd + gds
gmapHystI <- ggplot(df_hyst_map) +
geom_tile(aes(x = x, y = y, fill = hystI)) +
scale_fill_viridis_c(option = 'F', na.value = gry_land) +
coord_cartesian(expand = F, ylim = c(-54, 86)) +
lgd_map
gcspHystI <- ggplot(df_hyst_map) +
geom_tile(aes(x = t2.clim, y = sm.clim, fill = hystI)) +
scale_fill_viridis_c('HI', option = 'F') +
scale_x_continuous('Mean annual temperature') +
scale_y_continuous('Mean annual soil moisture') +
coord_cartesian(expand = F) +
ggtitle('Is hysteresis relatively important?', subtitle = '(Light mean YES, dark means NO)') +
lgd + gds
#### Export the figure ####
# assemble the figure
gAll <- gcspHystI +  gmapHystI +gcspBiasI +  gmapBiasI +
plot_layout(ncol = 2, widths = c(1,3))
# plotting details, in case not inherited...
if(exists('fig.path') != T){ fig.path <- 'paper/figures/'}
if(exists('fig.fmt') != T){ fig.fmt <- 'png'}
dir.create(path = fig.path, recursive = T, showWarnings = F)
fig.name <- 'hystereris_maps'
gAll
#### Initialization ####
require(ggplot2)
require(scales)
require(viridis)
require(tidyr)
#### Load the data ####
load('data/final_data/figures_for_paper/hysteresis_data_ready4fig.RData')   # <---- "df_r_all" "df_p_all" "df_s_all"
# some graphic param...
lgd <- theme(legend.position = 'left',
legend.key.height = unit(3, units = 'cm'),
panel.grid = element_blank(),
strip.text = element_text(size = 6))
# set-up colour palette
cols <- c(viridis(n = 6), magma(n = 6)[6:1])
## prepare the labeller function for the bins...
# t2m bins...
t2.clim.bin.values <- as.numeric(levels(df_s_all$t2.clim.bin))
t2.binwidth <- unique(diff(t2.clim.bin.values))/2
t2.clim.bin.labels <- paste(t2.clim.bin.values - t2.binwidth, '< T2m <',
t2.clim.bin.values + t2.binwidth)
names(t2.clim.bin.labels) <- levels(df_s_all$t2.clim.bin)
# # reverse t2m bins order
# df_s_all$t2.clim.bin <- factor(df_s_all$t2.clim.bin, levels = rev(levels(df_s_all$t2.clim.bin)))
# sm bins...
sm.clim.bin.values <- as.numeric(levels(df_s_all$sm.clim.bin))
sm.binwidth <- unique(round(diff(sm.clim.bin.values), digits = 6))/2
sm.clim.bin.labels <- paste(sm.clim.bin.values - sm.binwidth, '< SM <',
sm.clim.bin.values + sm.binwidth)
names(sm.clim.bin.labels) <- levels(df_s_all$sm.clim.bin)
# reverse sm bins order
df_s_all$sm.clim.bin <- factor(df_s_all$sm.clim.bin, levels = rev(levels(df_s_all$sm.clim.bin)))
# labeller...
climbin_labeller <- labeller(
t2.clim.bin = t2.clim.bin.labels,
sm.clim.bin = sm.clim.bin.labels)
#### Make the plot ####
g_all_smooth <- ggplot(df_s_all) +
geom_hline(yintercept = 0, colour = 'grey50') +
geom_vline(xintercept = 0, colour = 'grey50') +
geom_point(aes(x = x, y = y, colour = t),
shape = 20, size = 0.5) +
facet_grid(sm.clim.bin~t2.clim.bin, labeller = climbin_labeller) +
scale_colour_gradientn('', colours = cols, breaks = 1:12, labels = month.abb) +
scale_y_continuous('Bias in LST (ERA - obs)') +
scale_x_continuous('Bias in LAI (ERA - obs)', breaks = c(-1, 0, 1)) +
coord_cartesian(xlim = c(-1, 1.5), ylim = c(-20, 15)) +
ggtitle(label = paste0('Hysteresis patterns of biases between observational sources and variables in ERA5'),
subtitle = 'Analysized in a climate space defined by bins of mean annual 2m temperature (horizontally) \nand mean soil moisture (vertically)') +
theme(legend.position = 'right',
legend.key.height = unit(3, units = 'cm'),
panel.grid = element_blank(),
panel.spacing = unit(0, "lines"),
panel.border = element_rect(colour = 'white', fill = NA),
strip.text = element_text(size = 8, angle = 90),
strip.text.y = element_text(size = 8, angle = 0))
#### Export the figure ####
# plotting details, in case not inherited...
if(exists('fig.path') != T){ fig.path <- 'paper/figures/'}
if(exists('fig.fmt') != T){ fig.fmt <- 'png'}
dir.create(path = fig.path, recursive = T, showWarnings = F)
fig.name <- 'hystereris_climspace'
g_all_smooth
source('~/work/workspace/f4p-era5-analysis/code/harvesting_data_for_final_figures/prepare_gislayers_for_maps.R')
source('~/work/workspace/f4p-era5-analysis/code/making_figures_for_paper/plot_heatwaves.R')
source('~/work/workspace/f4p-era5-analysis/code/making_figures_for_paper/plot_heatwaves.R')
hw_labeller
hw_labeller
hw_labeller()
hw_labeller <- labeller(
hw = c('hw2003' = 'Aug. 2003', 'hw2010' = 'Jul. 2010', 'hw2018' = 'Jul. 2018'))
hw_lbls <- c('hw2003' = 'Aug. 2003', 'hw2010' = 'Jul. 2010', 'hw2018' = 'Jul. 2018')
hw_labeller <- labeller(hw = hw_lbls)
source('~/work/workspace/f4p-era5-analysis/code/making_figures_for_paper/plot_heatwaves.R')
